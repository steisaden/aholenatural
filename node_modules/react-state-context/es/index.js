var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import createReactContext from 'create-react-context';
import shallowEquals from './shallow-equals';
import { warning } from './warning';

function isValidState(state) {
  if (state && (typeof state === 'undefined' ? 'undefined' : _typeof(state)) !== 'object' || Array.isArray(state)) {
    return false;
  } else {
    return true;
  }
}

export default function createStateContext() {
  var actions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var initialState = arguments[1];

  var Context = createReactContext();

  var initialStateToUse = void 0;
  if (!isValidState(initialState)) {
    if (process.env.NODE_ENV !== 'production') {
      warning('Warning: StateContext state must be an object or null. You passed an invalid value to createStateContext' + ' that has been ignored.', 'INVALID_INITIAL_STATE');
    }
  } else {
    initialStateToUse = initialState;
  }

  if (process.env.NODE_ENV !== 'production') {
    if (actions && (typeof actions === 'undefined' ? 'undefined' : _typeof(actions)) !== 'object' || Array.isArray(actions)) {
      warning('You passed invalid actions to createStateContext. actions must be an object.', 'INVALID_ACTIONS_ARGUMENT');
    }
  }

  var ProviderComponent = function (_Component) {
    _inherits(ProviderComponent, _Component);

    _createClass(ProviderComponent, [{
      key: 'render',
      value: function render() {
        var children = this.props.children;


        return React.createElement(Context.Provider, { value: this.state, children: children });
      }
    }]);

    function ProviderComponent() {
      var _ref;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _classCallCheck(this, ProviderComponent);

      var _this = _possibleConstructorReturn(this, (_ref = ProviderComponent.__proto__ || Object.getPrototypeOf(ProviderComponent)).call.apply(_ref, [this].concat(args)));

      _this.onAction = function (returnValue) {
        var returnValueType = typeof returnValue === 'undefined' ? 'undefined' : _typeof(returnValue);

        // If the value is undefined, then we have no update to make.
        if (returnValueType === 'undefined') {
          return;
        }

        // If they pass a function, then the action is a thunk. We pass them
        // the setState wrapper.
        else if (returnValueType === 'function') {
            returnValue(_this.setStateWrapper);
          }

          // If it not undefined, nor a function, nor valid, then we log a warning and do nothing.
          else if (!isValidState(returnValue)) {
              if (process.env.NODE_ENV !== 'production') {
                warning('Warning: StateContext actions must update state to an object or null. You called an action that' + ' set an invalid value. This value has been ignored, and the state has not been updated.', 'INVALID_ACTION_UPDATE');
              }

              return;
            }

            // The last condition is if they return a plain object.
            // In that situation, we set the state after merging it.
            else {
                _this.setState(function (prevState) {
                  var merged = _this.getUpdatedState(prevState, returnValue);
                  return merged;
                });
              }
      };

      _this.getUpdatedState = function (prevState, newState) {
        if (!isValidState(newState)) {
          if (process.env.NODE_ENV !== 'production') {
            warning('Warning: StateContext actions must update state to an object or null. You called an action that' + ' set an invalid value. This value has been ignored, and the state has not been updated.', 'INVALID_ACTION_UPDATE');
          }

          return;
        }

        // To compute the _potential_ new state, we shallow merge the two.
        var mergedState = newState === null ? null : Object.assign({}, prevState.state, newState);

        // If the previous value and the new value are shallowly equal, then we avoid the update altogether.
        // In this way, a StateContext.Provider behaves similarly to a PureComponent.
        if (shallowEquals(prevState.state, mergedState)) {
          return;
        }

        return {
          state: mergedState
        };
      };

      _this.setStateWrapper = function (stateUpdate) {
        _this.setState(function (prevState) {
          // To compute the new state to merge with the old, we mimic the behavior of a Component's
          // `setState`, allowing you to pass either an object or a function.
          var newState = typeof stateUpdate === 'function' ? stateUpdate(prevState.state) : stateUpdate;

          return _this.getUpdatedState(prevState, newState);
        });
      };

      var actionsToUse = {};

      var _loop = function _loop(key) {
        var action = actions[key];

        if (typeof action !== 'function') {
          if (process.env.NODE_ENV !== 'production') {
            warning('Warning: an action with key ' + key + ' was passed to createStateContext that was not a function. Actions' + (' must be functions. The ' + key + ' action has been ignored. You should check your call to createStateContext().'), 'ACTION_MUST_BE_FN');
          }

          return 'continue';
        }

        if (key === 'state') {
          if (process.env.NODE_ENV !== 'production') {
            warning('Warning: an action was passed to createStateContext with the key "state". This is a reserved key,' + ' so your action has been ignored.', 'INVALID_ACTION_KEY');
          }

          return 'continue';
        }

        actionsToUse[key] = function () {
          return _this.onAction(action.apply(undefined, arguments));
        };
      };

      for (var key in actions) {
        var _ret = _loop(key);

        if (_ret === 'continue') continue;
      }

      // The Provider's `value` is this Component's state.
      // From the API of ReactStateContext, we know that a Provider's value has the form:
      //
      // {
      //   state,
      //   ...actions
      // }
      //
      // Together, those two facts lead to there being a state attribute on this Component's
      // state.
      _this.state = _extends({
        state: initialStateToUse
      }, actionsToUse);
      return _this;
    }

    // This function is what is called when you call an action.
    // `stateUpdate` is just similar to the first argument of `setState`, in that it can be
    // a function that is passed the previous state, or an update object.


    return ProviderComponent;
  }(Component);

  return {
    Provider: ProviderComponent,
    Consumer: Context.Consumer
  };
}